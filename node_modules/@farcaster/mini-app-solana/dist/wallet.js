import { frameHost, sdk } from '@farcaster/frame-sdk';
import { base58 } from '@scure/base';
import { SignAndSendAllTransactions, SolanaSignAndSendTransaction, SolanaSignMessage, SolanaSignTransaction, } from '@solana/wallet-standard-features';
import { StandardConnect, StandardDisconnect, StandardEvents, } from '@wallet-standard/features';
const supportedChains = ['solana:mainnet'];
const supportedFeatures = [
    StandardConnect,
    SolanaSignAndSendTransaction,
    SolanaSignTransaction,
    SolanaSignMessage,
];
export class FarcasterSolanaWallet {
    constructor() {
        this.listeners = {};
        this.connect = async () => {
            if (this.account) {
                return;
            }
            const provider = await sdk.wallet.getSolanaProvider();
            if (!provider) {
                throw new Error('could not get Solana provider');
            }
            const { publicKey: address } = await provider.request({
                method: 'connect',
            });
            this.account = new FarcasterSolanaAccount(address);
            this.emit('change', { accounts: this.accounts });
            return [this.account];
        };
        this.disconnect = () => {
            if (this.account) {
                this.account = undefined;
                this.emit('change', { accounts: this.accounts });
            }
        };
        this.on = (event, listener) => {
            if (this.listeners[event]) {
                this.listeners[event].push(listener);
            }
            else {
                this.listeners[event] = [listener];
            }
            return () => {
                this.listeners[event] = this.listeners[event]?.filter((existingListener) => listener !== existingListener);
            };
        };
        this.signMessage = async (...inputs) => {
            const outputs = [];
            for (const input of inputs) {
                const output = await this.signSingleMessage(input);
                outputs.push(output);
            }
            return outputs;
        };
        this.signTransaction = async (...inputs) => {
            const outputs = [];
            for (const input of inputs) {
                const output = await this.signSingleTransaction(input);
                outputs.push(output);
            }
            return outputs;
        };
        this.signAndSendTransaction = async (...inputs) => {
            const outputs = [];
            for (const input of inputs) {
                const output = await this.signAndSendSingleTransaction(input);
                outputs.push(output);
            }
            return outputs;
        };
        this.signAndSendAllTransactions = async (inputs, options) => {
            if (options?.mode === 'parallel') {
                return await Promise.allSettled(inputs.map((input) => this.signAndSendSingleTransaction(input)));
            }
            const outputs = [];
            for (const input of inputs) {
                try {
                    const output = await this.signAndSendSingleTransaction(input);
                    outputs.push({ status: 'fulfilled', value: output });
                }
                catch (e) {
                    outputs.push({ status: 'rejected', reason: e });
                }
            }
            return outputs;
        };
        void this.connect();
    }
    get version() {
        return '1.0.0';
    }
    get name() {
        return 'Farcaster';
    }
    get icon() {
        return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAxMjYwIDEyNjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzFfMikiPjxwYXRoIGQ9Ik05NDcuNzQ3IDEyNTkuNjFIMzExLjg2MUMxMzkuOTAxIDEyNTkuNjEgMCAxMTE5LjcyIDAgOTQ3Ljc1MlYzMTEuODcxQzAgMTM5LjkwNyAxMzkuOTAxIDAuMDA1NDEzNjIgMzExLjg2MSAwLjAwNTQxMzYySDk0Ny43NDdDMTExOS43MSAwLjAwNTQxMzYyIDEyNTkuNjEgMTM5LjkwNyAxMjU5LjYxIDMxMS44NzFWOTQ3Ljc1MkMxMjU5LjYxIDExMTkuNzIgMTExOS43MSAxMjU5LjYxIDk0Ny43NDcgMTI1OS42MVoiIGZpbGw9IiM0NzJBOTEiPjwvcGF0aD48cGF0aCBkPSJNODI2LjUxMyAzOTguNjMzTDc2NC40MDQgNjMxLjg4OUw3MDIuMDkzIDM5OC42MzNINTU4LjY5N0w0OTUuNzg5IDYzMy42MDdMNDMzLjA4NyAzOTguNjMzSDI2OS43NjRMNDIxLjUyOCA5MTQuMzZINTYyLjQzMUw2MjkuODA3IDY3NC44NzZMNjk3LjE4MSA5MTQuMzZIODM4LjM4OEw5ODkuODE5IDM5OC42MzNIODI2LjUxM1oiIGZpbGw9IndoaXRlIj48L3BhdGg+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcDBfMV8yIj48cmVjdCB3aWR0aD0iMTI1OS42MSIgaGVpZ2h0PSIxMjU5LjYxIiBmaWxsPSJ3aGl0ZSI+PC9yZWN0PjwvY2xpcFBhdGg+PC9kZWZzPjwvc3ZnPgo=';
    }
    get chains() {
        return supportedFeatures;
    }
    get features() {
        return {
            [StandardConnect]: {
                version: '1.0.0',
                connect: this.connect,
            },
            [StandardDisconnect]: {
                version: '1.0.0',
                disconnect: this.disconnect,
            },
            [StandardEvents]: {
                version: '1.0.0',
                on: this.on,
            },
            [SolanaSignMessage]: {
                version: '1.0.0',
                signMessage: this.signMessage,
            },
            [SolanaSignTransaction]: {
                version: '1.0.0',
                supportedTransactionVersions: ['legacy', 0],
                signTransaction: this.signTransaction,
            },
            [SolanaSignAndSendTransaction]: {
                version: '1.0.0',
                supportedTransactionVersions: ['legacy', 0],
                signAndSendTransaction: this.signAndSendTransaction,
            },
            [SignAndSendAllTransactions]: {
                version: '1.0.0',
                supportedTransactionVersions: ['legacy', 0],
                signAndSendAllTransactions: this.signAndSendAllTransactions,
            },
        };
    }
    get accounts() {
        return this.account ? [this.account] : [];
    }
    emit(event, ...args) {
        const listeners = this.listeners[event] ?? [];
        for (const listener of listeners) {
            listener.apply(null, args);
        }
    }
    async signSingleMessage(input) {
        const provider = await sdk.wallet.getSolanaProvider();
        if (!provider) {
            throw new Error('could not get Solana provider');
        }
        const { message } = input;
        const messageStr = Buffer.from(message).toString('utf8');
        const { signature } = await provider.signMessage(messageStr);
        const signatureBytes = Buffer.from(signature, 'base64');
        return { signedMessage: message, signature: signatureBytes };
    }
    async signSingleTransaction(input) {
        const provider = await sdk.wallet.getSolanaProvider();
        if (!provider || !frameHost.solanaProviderRequest) {
            // We check the provider to make sure that the frame host has the
            // capability, but we use the frame host directly below to avoid
            // unnecessary serialization/unserialization steps
            throw new Error('could not get Solana provider');
        }
        const solanaProviderRequest = frameHost.solanaProviderRequest;
        const { transaction } = input;
        const transactionStr = Buffer.from(transaction).toString('base64');
        const { signedTransaction } = await solanaProviderRequest({
            method: 'signTransaction',
            params: { transaction: transactionStr },
        });
        const signatureBytes = base58.decode(signedTransaction);
        return { signedTransaction: signatureBytes };
    }
    async signAndSendSingleTransaction(input) {
        const provider = await sdk.wallet.getSolanaProvider();
        if (!provider || !frameHost.solanaProviderRequest) {
            // We check the provider to make sure that the frame host has the
            // capability, but we use the frame host directly below to avoid
            // unnecessary serialization/unserialization steps
            throw new Error('could not get Solana provider');
        }
        const solanaProviderRequest = frameHost.solanaProviderRequest;
        const { transaction } = input;
        const transactionStr = Buffer.from(transaction).toString('base64');
        const { signature } = await solanaProviderRequest({
            method: 'signAndSendTransaction',
            params: { transaction: transactionStr },
        });
        const signatureBytes = base58.decode(signature);
        return { signature: signatureBytes };
    }
}
export class FarcasterSolanaAccount {
    constructor(address) {
        this.address = address;
        this.publicKey = base58.decode(address);
    }
    get chains() {
        return supportedChains;
    }
    get features() {
        return supportedFeatures;
    }
}
class RegisterWalletEvent extends Event {
    get type() {
        return 'wallet-standard:register-wallet';
    }
    constructor(callback) {
        super('wallet-standard:register-wallet', {
            bubbles: false,
            cancelable: false,
            composed: false,
        });
        this.detail = callback;
    }
    preventDefault() {
        throw new Error('preventDefault cannot be called');
    }
    stopImmediatePropagation() {
        throw new Error('stopImmediatePropagation cannot be called');
    }
    stopPropagation() {
        throw new Error('stopPropagation cannot be called');
    }
}
if (window) {
    const wallet = new FarcasterSolanaWallet();
    const callback = ({ register }) => register(wallet);
    try {
        window.dispatchEvent(new RegisterWalletEvent(callback));
    }
    catch (error) {
        console.error('wallet-standard:register-wallet event could not be dispatched', error);
    }
    try {
        ;
        window.addEventListener('wallet-standard:app-ready', ({ detail }) => callback(detail));
    }
    catch (error) {
        console.error('wallet-standard:app-ready event listener could not be added', error);
    }
}
