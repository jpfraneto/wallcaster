import { useState, useRef, useCallback, useEffect } from 'react';

// src/react/hooks/useUpload.ts

// src/utils/custom-errors.ts
var PinataError = class extends Error {
  constructor(message, statusCode, details) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
    this.name = "PinataError";
  }
};
var NetworkError = class extends PinataError {
  constructor(message, statusCode, details) {
    super(message, statusCode, details);
    this.name = "NetworkError";
  }
};
var AuthenticationError = class extends PinataError {
  constructor(message, statusCode, details) {
    super(message, statusCode, details);
    this.name = "AuthenticationError";
  }
};
var ValidationError = class extends PinataError {
  constructor(message, details) {
    super(message, void 0, details);
    this.name = "ValidationError";
  }
};

// src/utils/gateway-tools.ts
function isValidCIDv0(cid) {
  return /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/.test(cid);
}
function isValidCIDv1(cid) {
  return /^b[a-z2-7]{58,}$/.test(cid);
}
function isCID(str) {
  str = str.trim();
  return isValidCIDv0(str) || isValidCIDv1(str);
}
async function containsCID(input) {
  if (typeof input !== "string") {
    throw new Error("Input is not a string");
  }
  const startsWithCID = (str) => {
    const parts = str.split("/");
    return isCID(parts[0]) ? parts[0] : null;
  };
  const directCID = startsWithCID(input);
  if (directCID) {
    return {
      containsCid: true,
      cid: directCID
    };
  }
  let url;
  try {
    url = new URL(input);
  } catch (error) {
    const parts = input.split(/\/|\?/);
    for (const part of parts) {
      const cid = startsWithCID(part);
      if (cid) {
        return {
          containsCid: true,
          cid
        };
      }
    }
    return {
      containsCid: false,
      cid: null
    };
  }
  const subdomains = url.hostname.split(".");
  for (const subdomain of subdomains) {
    if (isCID(subdomain)) {
      return {
        containsCid: true,
        cid: subdomain
      };
    }
  }
  const pathParts = url.pathname.split("/");
  for (const part of pathParts) {
    const cid = startsWithCID(part);
    if (cid) {
      return {
        containsCid: true,
        cid
      };
    }
  }
  return {
    containsCid: false,
    cid: null
  };
}
async function convertToDesiredGateway(sourceUrl, desiredGatewayPrefix) {
  const results = await containsCID(sourceUrl);
  if (results.containsCid !== true) {
    throw new Error("url does not contain CID");
  }
  if (!sourceUrl.startsWith("https") && !sourceUrl.startsWith("ipfs://")) {
    return `${desiredGatewayPrefix}/ipfs/${sourceUrl}`;
  }
  const urlObj = new URL(sourceUrl);
  const path = urlObj.pathname + urlObj.search + urlObj.hash;
  if (sourceUrl.startsWith(`ipfs://${results.cid}`)) {
    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;
  }
  if (sourceUrl.includes(`/ipfs/${results.cid}`)) {
    return `${desiredGatewayPrefix}${path}`;
  }
  if (sourceUrl.includes(`/ipns/${results.cid}`)) {
    return `${desiredGatewayPrefix}${path}`;
  }
  if (urlObj.hostname.includes(results.cid)) {
    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;
  }
  throw new Error(
    "unsupported URL pattern, please submit a github issue with the URL utilized"
  );
}

// src/utils/resumable.ts
function getFileIdFromUrl(url) {
  const match = url.match(/\/files\/([^\/]+)/);
  if (match && match[1]) {
    return match[1];
  }
  throw new NetworkError("File ID not found in URL", 400, {
    error: "File ID not found in URL",
    code: "HTTP_ERROR",
    metadata: {
      requestUrl: url
    }
  });
}

// src/utils/format-config.ts
var formatConfig = (config) => {
  let gateway = config?.pinataGateway;
  if (config && gateway) {
    if (gateway && !gateway.startsWith("https://")) {
      gateway = `https://${gateway}`;
    }
    config.pinataGateway = gateway;
  }
  return config;
};

// src/react/hooks/useUpload.ts
var LARGE_FILE_THRESHOLD = 94371840;
var BASE_CHUNK_SIZE = 262144;
var DEFAULT_CHUNKS = 20 * 10;
var normalizeChunkSize = (size) => {
  if (size < BASE_CHUNK_SIZE) {
    return BASE_CHUNK_SIZE;
  }
  return Math.floor(size / BASE_CHUNK_SIZE) * BASE_CHUNK_SIZE;
};
var useUpload = () => {
  const [progress, setProgress] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [uploadResponse, setUploadResponse] = useState(
    null
  );
  const uploadUrlRef = useRef(null);
  const pausedRef = useRef(false);
  const cancelledRef = useRef(false);
  const uploadOffsetRef = useRef(0);
  const fileRef = useRef(null);
  const headersRef = useRef({});
  const lastResponseHeadersRef = useRef(null);
  const chunkSizeRef = useRef(BASE_CHUNK_SIZE * DEFAULT_CHUNKS);
  const resetState = useCallback(() => {
    setProgress(0);
    setError(null);
    setUploadResponse(null);
    uploadUrlRef.current = null;
    pausedRef.current = false;
    cancelledRef.current = false;
    uploadOffsetRef.current = 0;
    fileRef.current = null;
  }, []);
  const pause = useCallback(() => {
    pausedRef.current = true;
  }, []);
  const resume = useCallback(() => {
    if (pausedRef.current && uploadUrlRef.current && fileRef.current) {
      pausedRef.current = false;
      continueChunkedUpload();
    }
  }, []);
  const cancel = useCallback(() => {
    cancelledRef.current = true;
    setLoading(false);
  }, []);
  const continueChunkedUpload = useCallback(async () => {
    if (!uploadUrlRef.current || !fileRef.current) return;
    try {
      if (cancelledRef.current) {
        resetState();
        return;
      }
      if (pausedRef.current) return;
      const file = fileRef.current;
      const fileSize = file.size;
      const offset = uploadOffsetRef.current;
      const chunkSize = chunkSizeRef.current;
      if (offset >= fileSize) {
        await finalizeUpload();
        return;
      }
      const endOffset = Math.min(offset + chunkSize, fileSize);
      const chunk = file.slice(offset, endOffset);
      const uploadReq = await fetch(uploadUrlRef.current, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/offset+octet-stream",
          "Upload-Offset": offset.toString(),
          ...headersRef.current
        },
        body: chunk
      });
      lastResponseHeadersRef.current = uploadReq.headers;
      if (!uploadReq.ok) {
        const errorData = await uploadReq.text();
        throw new NetworkError(
          `HTTP error during chunk upload: ${errorData}`,
          uploadReq.status,
          {
            error: errorData,
            code: "HTTP_ERROR",
            metadata: { requestUrl: uploadReq.url }
          }
        );
      }
      const newOffset = endOffset;
      uploadOffsetRef.current = newOffset;
      const newProgress = Math.min(newOffset / fileSize * 100, 99.9);
      setProgress(newProgress);
      continueChunkedUpload();
    } catch (err) {
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(new Error("Unknown error during upload"));
      }
      setLoading(false);
    }
  }, [resetState]);
  const finalizeUpload = useCallback(async () => {
    if (!uploadUrlRef.current || !fileRef.current) return;
    try {
      let cid = null;
      if (lastResponseHeadersRef.current) {
        cid = lastResponseHeadersRef.current.get("upload-cid");
      }
      setUploadResponse(cid);
      setProgress(100);
      setLoading(false);
    } catch (err) {
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(new Error("Unknown error during upload finalization"));
      }
      setLoading(false);
    }
  }, []);
  const simpleUpload = async (file, network, url, options) => {
    try {
      const formData = new FormData();
      formData.append("file", file, file.name);
      formData.append("network", network);
      formData.append("name", options?.metadata?.name || file.name);
      if (options?.groupId) {
        formData.append("group_id", options.groupId);
      }
      if (options?.metadata?.keyvalues) {
        formData.append(
          "keyvalues",
          JSON.stringify(options.metadata.keyvalues)
        );
      }
      if (options?.streamable) {
        formData.append("streamable", "true");
      }
      const request = await fetch(url, {
        method: "POST",
        headers: headersRef.current,
        body: formData
      });
      if (!request.ok) {
        const errorData = await request.text();
        if (request.status === 401 || request.status === 403) {
          throw new AuthenticationError(
            `Authentication failed: ${errorData}`,
            request.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: { requestUrl: request.url }
            }
          );
        }
        throw new NetworkError(`HTTP error: ${errorData}`, request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: { requestUrl: request.url }
        });
      }
      const res = await request.json();
      setUploadResponse(res.data);
      setProgress(100);
      setLoading(false);
    } catch (err) {
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(new Error("Unknown error during upload"));
      }
      setLoading(false);
    }
  };
  const upload = useCallback(
    async (file, network, url, options) => {
      try {
        resetState();
        setLoading(true);
        fileRef.current = file;
        const headers = { Source: "sdk/react" };
        headersRef.current = headers;
        if (options?.chunkSize && options.chunkSize > 0) {
          chunkSizeRef.current = normalizeChunkSize(options.chunkSize);
        } else {
          chunkSizeRef.current = BASE_CHUNK_SIZE * DEFAULT_CHUNKS;
        }
        if (file.size <= LARGE_FILE_THRESHOLD) {
          await simpleUpload(file, network, url, options);
          return;
        }
        let metadata = `filename ${btoa(file.name)},filetype ${btoa(file.type)},network ${btoa(network)}`;
        if (options?.groupId) {
          metadata += `,group_id ${btoa(options.groupId)}`;
        }
        if (options?.metadata?.keyvalues) {
          metadata += `,keyvalues ${btoa(JSON.stringify(options.metadata.keyvalues))}`;
        }
        if (options?.streamable) {
          metadata += `,streamable ${btoa("true")}`;
        }
        const urlReq = await fetch(url, {
          method: "POST",
          headers: {
            "Upload-Length": `${file.size}`,
            "Upload-Metadata": metadata,
            ...headers
          }
        });
        if (!urlReq.ok) {
          const errorData = await urlReq.text();
          if (urlReq.status === 401 || urlReq.status === 403) {
            throw new AuthenticationError(
              `Authentication failed: ${errorData}`,
              urlReq.status,
              {
                error: errorData,
                code: "AUTH_ERROR"
              }
            );
          }
          throw new NetworkError("Error initializing upload", urlReq.status, {
            error: errorData,
            code: "HTTP_ERROR"
          });
        }
        const uploadUrl = urlReq.headers.get("Location");
        if (!uploadUrl) {
          throw new NetworkError("Upload URL not provided", urlReq.status, {
            error: "No location header found",
            code: "HTTP_ERROR"
          });
        }
        uploadUrlRef.current = uploadUrl;
        continueChunkedUpload();
      } catch (err) {
        if (err instanceof Error) {
          setError(err);
        } else {
          setError(new Error("Unknown error during upload initialization"));
        }
        setLoading(false);
      }
    },
    [resetState, continueChunkedUpload]
  );
  useEffect(() => {
    return () => {
      cancelledRef.current = true;
    };
  }, []);
  return {
    progress,
    loading,
    error,
    uploadResponse,
    upload,
    pause,
    resume,
    cancel
  };
};

export { AuthenticationError, NetworkError, PinataError, ValidationError, containsCID, convertToDesiredGateway, formatConfig, getFileIdFromUrl, useUpload };
//# sourceMappingURL=chunk-7UIMBFJ5.mjs.map
//# sourceMappingURL=chunk-7UIMBFJ5.mjs.map