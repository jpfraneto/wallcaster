import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_jsx_runtime
} from "./chunk-BT3QOQ5O.js";
import {
  frameHost,
  sdk
} from "./chunk-TZEWLHFB.js";
import {
  ConnectionProvider,
  SignAndSendAllTransactions,
  SolanaSignAndSendTransaction,
  SolanaSignMessage,
  SolanaSignTransaction,
  StandardConnect,
  StandardDisconnect,
  StandardEvents,
  WalletProvider,
  useWallet
} from "./chunk-7UD6QISG.js";
import {
  require_react
} from "./chunk-H5SXLDVB.js";
import "./chunk-BMNJHZLW.js";
import "./chunk-WKI7UJOK.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-W7YBHVXA.js";

// node_modules/@farcaster/mini-app-solana/dist/index.js
var import_dist10 = __toESM(require_dist());
var import_dist11 = __toESM(require_dist2());
var import_dist12 = __toESM(require_dist3());

// node_modules/@farcaster/mini-app-solana/dist/wallet.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);

// node_modules/@scure/base/lib/esm/index.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  afn(fn);
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
var radix2carry = (from, to) => from + (to - gcd(from, to));
var powers = (() => {
  let res = [];
  for (let i = 0; i < 40; i++)
    res.push(2 ** i);
  return res;
})();
function convertRadix2(data, from, to, padding2) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from];
  const mask = powers[to] - 1;
  const res = [];
  for (const n of data) {
    anumber(n);
    if (n >= max)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var base64 = hasBase64Builtin ? {
  encode(b) {
    abytes(b);
    return b.toBase64();
  },
  decode(s) {
    astr("base64", s);
    return Uint8Array.fromBase64(s, { lastChunkHandling: "strict" });
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b) {
    abytes(b);
    return b.toBase64({ alphabet: "base64url" });
  },
  decode(s) {
    astr("base64", s);
    return Uint8Array.fromBase64(s, { alphabet: "base64url" });
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes(data);
    return data.toHex();
  },
  decode(s) {
    astr("hex", s);
    return Uint8Array.fromHex(s);
  }
};
var hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/@farcaster/mini-app-solana/dist/wallet.js
var supportedChains = ["solana:mainnet"];
var supportedFeatures = [
  StandardConnect,
  SolanaSignAndSendTransaction,
  SolanaSignTransaction,
  SolanaSignMessage
];
var FarcasterSolanaWallet = class {
  constructor() {
    this.listeners = {};
    this.connect = async () => {
      if (this.account) {
        return;
      }
      const provider = await sdk.wallet.getSolanaProvider();
      if (!provider) {
        throw new Error("could not get Solana provider");
      }
      const { publicKey: address } = await provider.request({
        method: "connect"
      });
      this.account = new FarcasterSolanaAccount(address);
      this.emit("change", { accounts: this.accounts });
      return [this.account];
    };
    this.disconnect = () => {
      if (this.account) {
        this.account = void 0;
        this.emit("change", { accounts: this.accounts });
      }
    };
    this.on = (event, listener) => {
      if (this.listeners[event]) {
        this.listeners[event].push(listener);
      } else {
        this.listeners[event] = [listener];
      }
      return () => {
        var _a;
        this.listeners[event] = (_a = this.listeners[event]) == null ? void 0 : _a.filter((existingListener) => listener !== existingListener);
      };
    };
    this.signMessage = async (...inputs) => {
      const outputs = [];
      for (const input of inputs) {
        const output = await this.signSingleMessage(input);
        outputs.push(output);
      }
      return outputs;
    };
    this.signTransaction = async (...inputs) => {
      const outputs = [];
      for (const input of inputs) {
        const output = await this.signSingleTransaction(input);
        outputs.push(output);
      }
      return outputs;
    };
    this.signAndSendTransaction = async (...inputs) => {
      const outputs = [];
      for (const input of inputs) {
        const output = await this.signAndSendSingleTransaction(input);
        outputs.push(output);
      }
      return outputs;
    };
    this.signAndSendAllTransactions = async (inputs, options) => {
      if ((options == null ? void 0 : options.mode) === "parallel") {
        return await Promise.allSettled(inputs.map((input) => this.signAndSendSingleTransaction(input)));
      }
      const outputs = [];
      for (const input of inputs) {
        try {
          const output = await this.signAndSendSingleTransaction(input);
          outputs.push({ status: "fulfilled", value: output });
        } catch (e) {
          outputs.push({ status: "rejected", reason: e });
        }
      }
      return outputs;
    };
    void this.connect();
  }
  get version() {
    return "1.0.0";
  }
  get name() {
    return "Farcaster";
  }
  get icon() {
    return "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAxMjYwIDEyNjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzFfMikiPjxwYXRoIGQ9Ik05NDcuNzQ3IDEyNTkuNjFIMzExLjg2MUMxMzkuOTAxIDEyNTkuNjEgMCAxMTE5LjcyIDAgOTQ3Ljc1MlYzMTEuODcxQzAgMTM5LjkwNyAxMzkuOTAxIDAuMDA1NDEzNjIgMzExLjg2MSAwLjAwNTQxMzYySDk0Ny43NDdDMTExOS43MSAwLjAwNTQxMzYyIDEyNTkuNjEgMTM5LjkwNyAxMjU5LjYxIDMxMS44NzFWOTQ3Ljc1MkMxMjU5LjYxIDExMTkuNzIgMTExOS43MSAxMjU5LjYxIDk0Ny43NDcgMTI1OS42MVoiIGZpbGw9IiM0NzJBOTEiPjwvcGF0aD48cGF0aCBkPSJNODI2LjUxMyAzOTguNjMzTDc2NC40MDQgNjMxLjg4OUw3MDIuMDkzIDM5OC42MzNINTU4LjY5N0w0OTUuNzg5IDYzMy42MDdMNDMzLjA4NyAzOTguNjMzSDI2OS43NjRMNDIxLjUyOCA5MTQuMzZINTYyLjQzMUw2MjkuODA3IDY3NC44NzZMNjk3LjE4MSA5MTQuMzZIODM4LjM4OEw5ODkuODE5IDM5OC42MzNIODI2LjUxM1oiIGZpbGw9IndoaXRlIj48L3BhdGg+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcDBfMV8yIj48cmVjdCB3aWR0aD0iMTI1OS42MSIgaGVpZ2h0PSIxMjU5LjYxIiBmaWxsPSJ3aGl0ZSI+PC9yZWN0PjwvY2xpcFBhdGg+PC9kZWZzPjwvc3ZnPgo=";
  }
  get chains() {
    return supportedFeatures;
  }
  get features() {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: this.connect
      },
      [StandardDisconnect]: {
        version: "1.0.0",
        disconnect: this.disconnect
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: this.on
      },
      [SolanaSignMessage]: {
        version: "1.0.0",
        signMessage: this.signMessage
      },
      [SolanaSignTransaction]: {
        version: "1.0.0",
        supportedTransactionVersions: ["legacy", 0],
        signTransaction: this.signTransaction
      },
      [SolanaSignAndSendTransaction]: {
        version: "1.0.0",
        supportedTransactionVersions: ["legacy", 0],
        signAndSendTransaction: this.signAndSendTransaction
      },
      [SignAndSendAllTransactions]: {
        version: "1.0.0",
        supportedTransactionVersions: ["legacy", 0],
        signAndSendAllTransactions: this.signAndSendAllTransactions
      }
    };
  }
  get accounts() {
    return this.account ? [this.account] : [];
  }
  emit(event, ...args) {
    const listeners = this.listeners[event] ?? [];
    for (const listener of listeners) {
      listener.apply(null, args);
    }
  }
  async signSingleMessage(input) {
    const provider = await sdk.wallet.getSolanaProvider();
    if (!provider) {
      throw new Error("could not get Solana provider");
    }
    const { message } = input;
    const messageStr = Buffer.from(message).toString("utf8");
    const { signature } = await provider.signMessage(messageStr);
    const signatureBytes = Buffer.from(signature, "base64");
    return { signedMessage: message, signature: signatureBytes };
  }
  async signSingleTransaction(input) {
    const provider = await sdk.wallet.getSolanaProvider();
    if (!provider || !frameHost.solanaProviderRequest) {
      throw new Error("could not get Solana provider");
    }
    const solanaProviderRequest = frameHost.solanaProviderRequest;
    const { transaction } = input;
    const transactionStr = Buffer.from(transaction).toString("base64");
    const { signedTransaction } = await solanaProviderRequest({
      method: "signTransaction",
      params: { transaction: transactionStr }
    });
    const signatureBytes = base58.decode(signedTransaction);
    return { signedTransaction: signatureBytes };
  }
  async signAndSendSingleTransaction(input) {
    const provider = await sdk.wallet.getSolanaProvider();
    if (!provider || !frameHost.solanaProviderRequest) {
      throw new Error("could not get Solana provider");
    }
    const solanaProviderRequest = frameHost.solanaProviderRequest;
    const { transaction } = input;
    const transactionStr = Buffer.from(transaction).toString("base64");
    const { signature } = await solanaProviderRequest({
      method: "signAndSendTransaction",
      params: { transaction: transactionStr }
    });
    const signatureBytes = base58.decode(signature);
    return { signature: signatureBytes };
  }
};
var FarcasterSolanaAccount = class {
  constructor(address) {
    this.address = address;
    this.publicKey = base58.decode(address);
  }
  get chains() {
    return supportedChains;
  }
  get features() {
    return supportedFeatures;
  }
};
var RegisterWalletEvent = class extends Event {
  get type() {
    return "wallet-standard:register-wallet";
  }
  constructor(callback) {
    super("wallet-standard:register-wallet", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    this.detail = callback;
  }
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
if (window) {
  const wallet = new FarcasterSolanaWallet();
  const callback = ({ register }) => register(wallet);
  try {
    window.dispatchEvent(new RegisterWalletEvent(callback));
  } catch (error) {
    console.error("wallet-standard:register-wallet event could not be dispatched", error);
  }
  try {
    ;
    window.addEventListener("wallet-standard:app-ready", ({ detail }) => callback(detail));
  } catch (error) {
    console.error("wallet-standard:app-ready event listener could not be added", error);
  }
}

// node_modules/@farcaster/mini-app-solana/dist/provider.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var wallets = [];
var FarcasterSolanaProvider = React.memo(({ endpoint, children }) => (0, import_jsx_runtime.jsx)(ConnectionProvider, { endpoint, children: (0, import_jsx_runtime.jsxs)(WalletProvider, { wallets, autoConnect: true, children: [(0, import_jsx_runtime.jsx)(FarcasterSolanaWalletSelector, {}), children] }) }));
function FarcasterSolanaWalletSelector() {
  const { wallets: wallets2, select, connect } = useWallet();
  const farcasterWallet = wallets2.find((w) => w.adapter.name === "Farcaster");
  React.useEffect(() => {
    if (!farcasterWallet) {
      console.error("failed to detected Farcaster Solana wallet");
      return;
    }
    ;
    (async () => {
      try {
        await select(farcasterWallet.adapter.name);
        await connect();
      } catch (e) {
        console.error("failed to select Farcaster Solana wallet", e);
      }
    })();
  }, [farcasterWallet, select, connect]);
  return null;
}
export {
  FarcasterSolanaProvider
};
/*! Bundled license information:

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@farcaster_mini-app-solana.js.map
